<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Intro to Game Dev Part 1</title>

    <meta name="description" content="Introduction to Game Development: Part 1">
    <meta name="author" content="Holden Profit">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="./css/reveal.min.css">
    <link rel="stylesheet" href="./css/theme/default.css" id="theme">
    <link rel="stylesheet" href="./css/custom.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="./lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
        if (window.location.search.match(/print-pdf/gi)) {
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'css/print/pdf.css';
            document.getElementsByTagName('head')[0].appendChild(link);
        }
    </script>

    <!--[if lt IE 9]>
    <script src="./lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body class="ai-pres">
<div class="reveal">
    <div class="slides">
        <!-- Intro -->
        <section>
            <h1>Intro to Game Development</h1>
            <h2>Part 1</h2>
            <p>
                Holden Profit <br>
            </p>
        </section>

        <section>
            <h2>Course Overview</h2>
            <p>
                Over the next few weeks, you'll learn the fundamentals of game development.
                We'll cover the anatomy of a game, basic physics, and even some artificial intelligence.
                <br><br>
                At the end of the class you'll be able to build your own 2D game
                which will be demonstrated as the class capstone project. Primary
                technology used will be Javascript ES6 and <a href="https://phaser.io/">Phaser</a>.
            </p>
        </section>

        <!-- Course Outline -->
        <!-- <section>
          <h3>Course Outline</h3>
          <p>
            <ul>
              <li>Part 1 - Structure of a Game</li>
              <li>Part 2 - Physics</li>
              <li>Part 3 - Enemies</li>
              <li>Part 4 - Optimization</li>
            </ul>
          </p>
        </section> -->

        <!-- What is a Game? -->
        <section>
            <section>
                <h2>So what is a game?</h2>
                <p>
                    Games are media just like movies and books, but what separates them from these things?
                    <br><br>
                    They're <i>interactive</i> media! This makes it a powerful way to tell stories and enjoy
                    all kinds of experiences!
                </p>
            </section>

            <section>
                <h2>Modern AAA Games</h2>
                <p>Amazing Games with tons of developers and huge budgets!</p>
            </section>

            <section>
                <img src="image/introToGame_1/gameExamples/uncharted4.jpg"/>
                <p>
                    <small><i>Uncharted 4: A Thief's End - Naughty Dog</i></small>
                </p>
            </section>

            <section>
                <img src="image/introToGame_1/gameExamples/overwatch.png"/>
                <p>
                    <small><i>Overwatch - Blizzard</i></small>
                </p>
            </section>

            <section>
                <img src="image/introToGame_1/gameExamples/darkSouls3.jpg"/>
                <p>
                    <small><i>Dark Souls 3 - From Software</i></small>
                </p>
            </section>

            <section>
                <h2>Those look cool!</h2>
                <p>
                    When can I make games like those?!
                </p>
            </section>
        </section>

        <!-- Smaller Games -->
        <section>
            <section>
                <h2>Hold on a second!</h2>
                <p>
                    We need to understand the basics of a game first! And that's
                    most easily done with simpler (probably 2D) games!
                </p>
            </section>

            <section>
                <img src="image/introToGame_1/gameExamples/marioBros.png"/>
                <p>
                    <small><i>Mario Bros. - Nintendo</i></small>
                </p>
            </section>

            <section>
                <img src="image/introToGame_1/gameExamples/megaman.jpg"/>
                <p>
                    <small><i>Megaman - Capcom</i></small>
                </p>
            </section>

            <section>
                <img src="image/introToGame_1/gameExamples/contra.jpg" style="height: 550px;"/>
                <p>
                    <small><i>Contra - Konami</i></small>
                </p>
            </section>

            <section>
                <h2>Okay, so how do I make that?</h2>
                <p>
                    I'm glad you asked!
                </p>
            </section>
        </section>

        <!-- Core Game Architecture -->
        <section>
            <section>
                <h2>where do we start?</h2>
                <p>
                    What actually <i>makes</i> a game?
                    <br>
                    What are the core ideas?
                </p>
            </section>

            <section>
                <h2>What Does a Game Actually Do?</h2>
                <ul>
                    <li>Respond to player input</li>
                    <li>Render graphics to the screen</li>
                    <li>Enforce game rules on entities</li>
                </ul>
            </section>

            <section>
                <h2>Basic Game Lifecycle</h2>
                <br>
                    <pre style="width: 700px; font-size: 36px;"><code data-trim>
let gameIsPlaying = true;
startup();
while (gameIsPlaying) {
    processInput();
    updateEntities();
    render();
}
tearDown();
                    </code></pre>
            </section>
        </section>

        <!-- Rendering -->
        <section>
            <section>
                <h3>Start by Rendering</h3>
                <p>
                    While it's the last step in the game loop process, it's the best
                    starting point because from there you can see your entity updates
                    and responses to input represented visually on the screen.
                </p>
            </section>

            <section>
                <h3>2-Dimensional Coordinates</h3>
                <p>
                    My guide to basic vector principals can be found <a href="http://acrylicorner.com/presentations/swarmIntelligence.html#/4" target="_blank">here.</a>
                    <br>
                    Vectors are a way to represent direction and velocity while Points represent a location in space.
                    <br>
                    For all intents and purposes, Vectors can almost always be used to represent a Point.
                </p>
            </section>

            <section>
                <h3>2-Dimensional Coordinates</h3>
                <p>
                    We use these Vectors to represent where an entity is within the world.<br>
                    Computer screen y coordinates almost always go in the opposite direction of your
                    typical graph.<br>

                    <img src="image/introToGame_1/grid/grid.png" style="height:400px"/>
                </p>
            </section>

            <section>
                <h3>2-Dimensional Coordinates</h3>
                <p>
                    If I want to render my sprite in the lower-middle of the screen, it'd look something like this:<br>

                    <img src="image/introToGame_1/grid/grid_spriteAtBottom.png" style="height:500px"/>
                </p>
            </section>

            <section>
                <h3>2-Dimensional Coordinates</h3>
                <p>
                    In addition to location, sprites will also have a rotatation and scale associated with them.
                    <br>
                    <img src="image/introToGame_1/grid/grid_spriteRotAndScale.png" style="height:500px"/>
                </p>
            </section>
        </section>

        <section>
            <section>
                <h2>Z-Index</h2>
                <p>
                    Despite being a 2D game, entities will also have a z coordinate known as a Z-Index.
                    <br><br>
                    The closer the Z-Index to the camera, the less likely it is to be drawn over by another entity.
                </p>
            </section>

            <section>
                <h3>Z-Index</h3>
                <p>
                    Z-Index allows us to create some neat effects, including psuedo 3D rendering:
                    <br>
                    <img src="image/introToGame_1/grid/rotatingSprite.gif" style="height: 500px"/>
                </p>
            </section>

            <section>
                <h3>Z-Index</h3>
                <p>
                    <br>
                    Z-Indexing can be used to easily split a 2D game into layers:
                    <br><br>
                    <ul>
                        <li>Background</li>
                        <li>Foreground</li>
                        <li>Entities</li>
                        <li>HUD</li>
                    </ul>
                    <br><br>
                    These layers can be rearranged or have layers added for visual effects as needed.
                </p>
            </section>

            <section>
                <h3>Layer - Background</h3>
                <img src="./image/introToGame_1/render/background.png"  style="height:500px" />
            </section>

            <section>
                <h3>Layer - Foreground</h3>
                <img src="./image/introToGame_1/render/foreground.png"  style="height:500px" />
            </section>

            <section>
                <h3>Layer - Entities</h3>
                <img src="./image/introToGame_1/render/entities.png"  style="height:500px" />
            </section>

            <section>
                <h3>Layer - HUD Elements</h3>
                <img src="./image/introToGame_1/render/hud.png"  style="height:500px" />
            </section>
        </section>

        <!-- Processing Input -->
        <section>
            <section>
                <h3>Processing Input</h3>
                <p>
                    There are many different control devices available out there and how you build your game depends
                    heavily on which methods you support.
                    <br><br>
                    <ul>
                        <li>Mouse + Keyboard (Can be used separately)</li>
                        <li>Game Pad (XBox, PS controller)</li>
                        <li>Motion Controls (Vive, WiiMote)</li>
                        <li>Touch (iPad, phones)</li>
                    </ul>
                    <br><br>
                    We'll be sticking to mouse and keyboard for this class as you most likely already have those.
                </p>
            </section>

            <section>
                <h3>Processing Input</h3>
                <br>
                    <pre style="width: 600px;"><code data-trim>
class Player {
    ...
    handleInput(keys) {
        ...
    }
}

let processInput = function(player) {
    // Grab the directional keys and
    // pass them to the player
    let pressedKeys = keyboard.createCursorKeys();
    player.handleInput(pressedKeys);
};
                    </code></pre>
            </section>

            <section>
                <h3>Processing Input</h3>
                <br>
                    <pre style="width: 550px;"><code data-trim>
class Player {
    ...
    handleInput(keys) {
        if (keys.left.isDown) {
            // Move to the left
            this.x -= 10;
        }
        else if (keys.right.isDown) {
            // Move to the right
            this.x += 10;
        }
    }
}
                    </code></pre>
                <br>
                Why might this be a bad idea?
            </section>

            <section>
                <h3>Processing Input</h3>
                <br>
                The previous approach will move the player, but is at the mercy of the frame rate of the game.
                <br>
                A better method is to use velocity, which is the entity's rate of movement per update
            </section>

            <section>
                <h3>Processing Input</h3>
                <br>
                    <pre style="width: 550px;"><code data-trim>
class Player {
    ...
    handleInput(keys) {
        // Reset player velocity
        this.velocity.x = 0;

        if (keys.left.isDown) {
            // Move to the left
            this.velocity.x = -100;
        }
        else if (keys.right.isDown) {
            // Move to the right
            this.velocity.x = 100;
        }
    }
}
                    </code></pre>
            </section>

            <section>
                <h3>Processing Input</h3>
                <br>
                    <pre style="width: 700px;"><code data-trim>
class Player {
    ...
    update(deltaTime) {
        // Increment x pos by x velocity multiplied
        // by time since last update
        this.x += this.velocity.x * deltaTime;
    }
}
                    </code></pre>
            </section>
        </section>

        <!-- Enforcing Game Rules -->
        <section>
            <section>
                <h3>Enforcing Game Rules</h3>
                <p>
                    So now that we have basic player input, what do we do with it?
                    <br>
                    Enforcing our game rules is what actually <i>makes</i> the game!
                </p>
            </section>

            <section>
                <h3>Enforcing Game Rules</h3>
                <p>
                    What sort of rules might we have?
                    <ul>
                        <li>Limitations on character action</li>
                        <li>Enemies that antagonize the player</li>
                        <li>Friendly NPCs that help the player</li>
                        <li>Physical interactions with the world</li>
                    </ul>
                    <br><br>
                    There can be more or less depending on the type of game you're building!
                </p>
            </section>

            <section>
                <h3>Enforcing Game Rules</h3>
                <p>
                    Perhaps the most immediately obvious rule to enforce is physics.
                    <br>
                    <br>
                    While not all games necessarily need physics, a good deal of games need at least simple physics to run.
                    <br>
                    <br>
                    Physics can range from simple circle-to-circle collision and gravity to more complex 3D object collisions and force calculations.
                </p>
            </section>
        </section>

        <!-- Basic Gravity -->
        <section>
            <section>
                <h3>Gravity</h3>
                <p>
                    Earlier we made our player move left and right, but didn't implement any sort of jump ability. This
                    is because we didn't yet have any form of gravity!
                </p>
            </section>

            <section>
                <h3>Gravity</h3>
                <pre style="width: 700px;"><code data-trim>
let applyGravity = function(deltaTime, entity) {
    // If the entity's velocity is less than the constant
    // gravity velocity, increment it until it is equal to
    if (entity.velocity.y < CONST_GRAVITY) {
        entity.velocity.y += CONST_GRAVITY * deltaTime;
    }
    else {
        entity.velocity.y = CONST_GRAVITY;
    }
    // Increment y pos by y velocity multiplied
    // by time since last update
    entity.y += entity.velocity.y * deltaTime;
}
                </code></pre>
            </section>
        </section>

        <section>
            <section>
                <h3>Collisions</h3>
                <p>
                    How <i>does</i> the computer know all these objects are colliding? Math.
                    <br><br>
                    Lots and lots of math.
                    <br><br>
                    Let's start with the easiest form of collision...
                </p>
            </section>

            <section>
                <h3>Circle on Circle</h3>
                <img src="./image/introToGame_1/physics/circle_circle.png"  style="height:500px" />
            </section>

            <section>
                <h3>Circle on Circle</h3>
<pre style="width: 1000px; font-size: 26px;"><code data-trim>
// circleA and circleB both have a Vector2 position
// object and a radius
let collideCircles = function(circleA, circleB) {
    let currentDistance = circleA.position - circleB.position;
    currentDistance = currentDistance.length();
    let collisionDistance = circleA.radius + circleB.radius;
    return currentDistance <= collisionDistance;
}
</code></pre>
            </section>


            <section>
                <h3>AABB on AABB</h3>
                AABB: Axis Aligned Bounding Box
                <br><br>
                <!--TODO: PUT IMAGE HERE-->
                <!--<img src="./image/introToGame_1/physics/circle_circle.png"  style="height:500px" />-->
            </section>

            <section>
                <h3>AABB on AABB</h3>
<pre style="width: 1000px; font-size: 26px;"><code data-trim>
// rectA and rectB both have an X, Y, width, and height
let collideAABB = function(rectA, rectB) {
    return (rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.height + rectA.y > rectB.y);
}
</code></pre>
            </section>


            <section>
                <h3>Circle on AABB</h3>
                This is a bit more involved than the previous two forms of collision.
                <br><br>
                It can be broken up into three parts, the first two serving as a sort of
                "definitely inside/outside the AABB" for the circle.
            </section>

            <section>
                <h3>Circle on AABB</h3>
                <!--TODO: PUT IMAGE HERE-->
                <!--<img src="./image/introToGame_1/physics/circle_circle.png"  style="height:500px" />-->
            </section>

            <section>
                <h3>Circle on AABB</h3>
<pre style="width: 1000px; font-size: 26px;"><code data-trim>

</code></pre>
            </section>

        </section>

        <!-- Questions -->
        <section>
            <h2>Questions</h2>
            <p>
                <a href="https://www.linkedin.com/pub/holden-profit/42/634/a23">Holden Profit</a>
                <br>
                <a href="mailto:holdenprofit@gmail.com?Subject=Reaching%20Out">holdenprofit@gmail.com</a>
                <br>
                <a href="https://github.com/hprofit">GitHub</a>
            </p>
        </section>

        <!-- Sources -->
        <!--<section>-->
            <!--<h2>Sources</h2>-->
            <!--<p>-->

            <!--</p>-->
        <!--</section>-->
    </div>
</div>

<script src="./lib/js/head.min.js"></script>
<script src="./js/reveal.min.js"></script>
<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'concave', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
            {
                src: './lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: './plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: './plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: './plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {
                src: './plugin/zoom-js/zoom.js', async: true, condition: function () {
                return !!document.body.classList;
            }
            },
            {
                src: './plugin/notes/notes.js', async: true, condition: function () {
                return !!document.body.classList;
            }
            }
        ]
    });

</script>
</body>
</html>
